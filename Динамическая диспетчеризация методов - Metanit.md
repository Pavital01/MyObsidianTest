#Metanit #Наследование
[[2022-07-10]]
Наследование и возможность переопределения методов открывают нам большие возможности. Прежде всего мы можем передать переменной суперкласса ссылку на объект подкласса:

```java 
Person sam = new Employee("Sam","Oracle");
```

Так как Employee наследуется от Person, то объект Employee является в то же время и объектом Person. Грубо говоря, любой работник предприятия одновременно является человеком.

Однако несмотря на то, что переменная представляет объект Person, виртуальная машина видит, что в реальности она указывает на объект Employee. Поэтому при вызове методов у этого объекта будет вызываться та версия метода, которая определена в классе Employee, а не в Person.
___
Q/A
-- А зачем создавать объект типа Person и присваивать ему тип Employee? Вот какова реальная польза от такой возможности?
-- Нередки такие ситуации, когда программист получает объекты базового класса, но точно неизвестно, представяют эти объекты только базовый класс или один из производных классов. Здесь эмуляция подобной возможности.
--Польза, когда наследников много и надо набрать их в одну типизированную коллекцию, например:
```java
class Handler{...}  
class FirstHandler extends Handler {...}  
class SecondHandler extends Handler {...}  
...  
class LastHandler extendes Handler {...}

Map map = new HashMap<handler>();  
map.put("first", firstHandler);  
...  
map.put("last", lastHandler);  
...  
map.get("second").doSomething();
```
https://metanit.com/java/tutorial/3.5.php